Фабричный метод - порождающий паттерн проектирования, который определяет общий интерфейс для создания
объектов в суперклассе, позволяя подклассам самим изменять тип создаваемых объектов.

Проблема: при попытке реализовать в одном классе функционал, имеющий общие черты, но разные детали в реализации
код класса становится громоздким и запутанным +  усложняется задача  дальнейшего расширения.

Решение: создавать новые объекты посредством отдельного метода, объявленного в суперклассе с дальнейшей возможностью
подмены инстанса на необходимый экземпляр класса-наследника с нужным функционалом. При этом поведение желательно вынести
в интерфейс, который будут реализовывать все классы.

Структура:
- интерфейс с функционалом, который может быть реализован разными способами
- конкретные реализации интерфейса с выбранными способами
- абстрактный класс, содержащий внутреннюю бизнес-логику, не зависящую от конкретной реализации функционала
 и метод-фабрику для создания разных вариантов функционала
- реализации абстрактного класса, реализующие метод-фабрику с конкретной реализацией необходимого функционала
- тестовый класс, в котором будет проводиться проверка

Применимость:
- когда заранее неизвестны типы и зависимости объектов, с которыми должен работать код (то есть мы можем в случае необходимости
объявить новую реализацию абстрактного класса с реализацией того функционала, который нужен под текущую задачу)
- когда нужно дать возможность пользователям расширять части созданного фреймворка/библиотеки (суть в том, что при добавлении
нового функционала в уже существующую библиотеку можно унаследоваться от какого то класса, который реализует функционал, ибо
он скорее всего будет открытым, но классы, взаимодействующие с открытой частью API могут быть скрыты. Если есть фабричный
метод, то можно переопределить и управляющие классы (наверное)
- когда нужно экономить системные ресурсы, повторно используя уже созданные объекты вместо порождения новых. При работе с
тяжёлыми объектами при создании нового объекта каждый раз необходимо проверить наличие объекта в хранилище, если его нет
создать новый и добавить его в хранилище. Такие проверки удобнее всего помещать в конструктор, так как они нужны при создании
нового объекта, но конструктор всегда создаёт новый объект. Вместо этого можно осуществлять эти проверки в фабричном методе

Преимущества:
- избавляет класс от привязки к конкретным классам продуктов
- выделяет код производства продуктов в одно место, упрощая поддержку кода
- упрощает добавление новых продуктов в программу
- реализует принцип SOLID, а именно OPEN|CLOSE PRINCIPLE

Недостатки:
- может привести к созданию больших параллельных иерархий классов, так как для каждого класса продукта
нужно создавать свой подкласс.
